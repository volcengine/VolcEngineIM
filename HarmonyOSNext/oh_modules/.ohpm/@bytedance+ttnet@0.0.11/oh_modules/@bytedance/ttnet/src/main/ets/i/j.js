import http from '@ohos.net.http'; import { HttpMethodEnum, ResponseBodyTypeEnum } from "../ttnet/a/c"; import { SsResponse } from "../ttnet/i1/j1"; import { TTNetworkError } from "../ttnet/l"; import { OhosErrorCodeMapping } from "../ttnet/r1"; import { Header } from "../ttnet/a/d"; import List from '@ohos.util.List'; import { HttpUtils } from "../ttnet/p/m1"; export class OhosHttpClient { newSsCall(request) { return new g7(request); } } class g7 { constructor(request) { this.isCanceled = false; this.httpStatusCode = -1; this.responseHeaders = new List(); this.j = false; this.originRequest = request; this.httpRequest = http.createHttp(); let dataType = this.m(request.getResponseType()); let y7 = this.o(request.getMethod()); let proxy = request.getHttpProxy(); let caPath = request.getCaPath(); let connectTimeout = request.getConnectTimeout(); let readTimeout = request.getReadTimeout(); this.options = { expectDataType: dataType, method: y7, usingProtocol: http.HttpProtocol.HTTP2, usingProxy: proxy, connectTimeout: connectTimeout, readTimeout: readTimeout, caPath: caPath }; if (y7 === http.RequestMethod.POST || y7 === http.RequestMethod.PUT) { let body = request.getRequestBody(); if (body) { this.options.extraData = body; } else { this.options.extraData = HttpUtils.NULL_BODY_STRING; } } } getRequest() { return this.originRequest; } o(method) { switch (method) { case HttpMethodEnum.GET: return http.RequestMethod.GET; case HttpMethodEnum.POST: return http.RequestMethod.POST; case HttpMethodEnum.HEAD: return http.RequestMethod.HEAD; case HttpMethodEnum.PUT: return http.RequestMethod.PUT; case HttpMethodEnum.DELETE: return http.RequestMethod.DELETE; case HttpMethodEnum.OPTIONS: return http.RequestMethod.OPTIONS; default: break; } return http.RequestMethod.GET; } m(type) { if (type === ResponseBodyTypeEnum.STRING) { return http.HttpDataType.STRING; } if (type === ResponseBodyTypeEnum.ARRAYBUFFER) { return http.HttpDataType.ARRAY_BUFFER; } return http.HttpDataType.STRING; } async t() { try { let headers = HttpUtils.checkAndAddUserAgent(this.originRequest.getHeaders(), g7.u); let obj = {}; for (let header of headers) { obj[header.getName()] = header.getValue(); } this.options.header = obj; } catch (e) { throw new Error("addCommonHeaders failed"); } } async execute() { if (this.isCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); throw error; } try { await this.t(); } catch (e) { throw e; } return new Promise((r7, s7) => { this.httpRequest.request(this.originRequest.getUrl(), this.options, (err, data) => { if (this.isCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); s7(error); } if (!err) { this.httpStatusCode = data.responseCode; if (this.httpStatusCode < 200 || this.httpStatusCode >= 300) { let x7 = new TTNetworkError("Response code is not 2xx:" + this.httpStatusCode); x7.setHttpStatusCode(this.httpStatusCode); x7.setResponseHeaders(new Map(Object.entries(JSON.parse(JSON.stringify(data.header))))); x7.setResponseError(JSON.stringify(data.result)); s7(x7); } const v7 = new Map(Object.entries(data.header)); const headers = new List(); v7.forEach((value, key) => { headers.add(new Header(key, value)); }); let response = new SsResponse(this.originRequest.getUrl(), data.responseCode, headers, data.result); r7(response); } else { let u7 = new TTNetworkError(JSON.stringify(err)); u7.setErrorMessage(err.message); u7.setNetErrorCode(g7.a1(err.code)); s7(u7); } this.httpRequest.destroy(); }); }); } static a1(code) { let error = OhosErrorCodeMapping.convertOhosNetErrorCode(code); if (error < 0) { return error; } return code; } async executeInStreamCallback(callback) { if (this.isCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); throw error; } try { await this.t(); } catch (e) { throw e; } this.j = true; this.b1 = callback; this.options.extraData = http.HttpDataType.ARRAY_BUFFER; this.httpRequest.requestInStream(this.originRequest.getUrl(), this.options, (err, data) => { if (this.isCanceled) { return; } if (!err) { this.httpStatusCode = data; let response = new SsResponse(this.originRequest.getUrl(), this.httpStatusCode, this.responseHeaders, ""); callback.onSucceed(response); } else { callback.onError(new TTNetworkError(JSON.stringify(err))); } }); this.httpRequest.on("headersReceive", (header) => { const o7 = new Map(Object.entries(header)); o7.forEach((value, key) => { this.responseHeaders.add(new Header(key, value)); }); if (this.responseHeaders.length > 2) { const response = new SsResponse(this.originRequest.getUrl(), this.httpStatusCode, this.responseHeaders, ""); callback.onHeaderComplete(response); } }); this.httpRequest.on("dataReceive", (data) => { callback.onDataComplete(data); }); this.httpRequest.on("dataEnd", () => { }); } async executeUploadInStream(callback) { if (this.isCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); throw error; } return new Promise((i7, j7) => { }); } executeBothInStream(upload, callback) { throw new Error('Method not implemented.'); } cancel() { this.isCanceled = true; if (this.j) { this.httpRequest.off("headersReceive"); this.httpRequest.off("dataReceive"); this.httpRequest.off("dataEnd"); let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); if (this.b1) { this.b1.onError(error); } } this.httpRequest.destroy(); } request() { return this.originRequest; } } g7.TAG = "OhosCall"; g7.u = "ohos/1.0.0"; 