import connection from '@ohos.net.connection'; import { TTNetworkChangeNotifier } from '@bytedance/cronet'; import { TTLogger } from "../ttnet/p/l1"; import List from '@ohos.util.List'; export class OhosNetworkLibrary { constructor() { this.defaultConnection = connection.createNetConnection(); this.mRegistered = false; this.default_net_id = -1; this.default_net_type = "NONE"; this.default_proxy = ""; this.default_availability = false; this.default_has_vpn = false; this.current_net_id = this.default_net_id; this.current_net_type = this.default_net_type; this.current_availability = this.default_availability; this.current_has_vpn = this.default_has_vpn; this.current_proxy = this.default_proxy; this.timerId = -1; this.current_all_nets = new Map(); this.isNotifyOnInit = true; } initNotifyCronet(f7) { if (f7 && !this.mRegistered) { this.mRegistered = true; this.registerEvent(); } else { this.mRegistered = false; this.unregisterEvent(); } } setEnableRefreshProxy(enable, d7) { if (enable) { clearInterval(this.timerId); this.timerId = setInterval(() => { this.refreshProxy(); }, d7 * 1000); } else { clearInterval(this.timerId); } } registerEvent() { this.defaultConnection.register((error) => { TTLogger.info(OhosNetworkLibrary.TAG, " registering"); if (error) { return; } this.defaultConnection.on('netCapabilitiesChange', (a7) => { if (!this.cronetNetworkChangeNotifier) { return; } const log = "connection event netCapabilitiesChange, info is " + JSON.stringify(a7); TTLogger.info(OhosNetworkLibrary.TAG, log); this.refreshDefaultNetState(); const b7 = this.getNetBearTypeFromNetCapabilities(a7.netCap); const c7 = this.hasVPN(a7.netCap); const handle = a7.netHandle; if (this.isNetworkAvailable(a7.netCap)) { OhosNetworkLibrary.eventHistory.add("-----netCapabilitiesChange true" + b7 + " " + handle.netId + " " + c7); this.notifyCronetConnected(handle, b7, c7); } else { OhosNetworkLibrary.eventHistory.add("-----netCapabilitiesChange false" + b7 + " " + handle.netId + " " + c7); this.notifyCronetDisconnect(handle); } }); this.defaultConnection.on('netLost', (handle) => { const log = "connection event netLost, handle is " + handle.netId; TTLogger.info(OhosNetworkLibrary.TAG, log); OhosNetworkLibrary.eventHistory.add("-----netLost " + handle.netId); this.refreshDefaultNetState(); this.notifyCronetDisconnect(handle); }); this.defaultConnection.on('netAvailable', (handle) => { TTLogger.info(OhosNetworkLibrary.TAG, "connection event netAvailable, handle is " + handle.netId); }); this.defaultConnection.on('netConnectionPropertiesChange', (data) => { TTLogger.info(OhosNetworkLibrary.TAG, "connection event netConnectionPropertiesChange" + JSON.stringify(data)); }); this.defaultConnection.on('netUnavailable', () => { TTLogger.info(OhosNetworkLibrary.TAG, "connection event netUnavailable"); }); this.defaultConnection.on('netBlockStatusChange', (data) => { TTLogger.info(OhosNetworkLibrary.TAG, "connection event netBlockStatusChange"); }); }); } notifyCronetConnected(handle, r6, s6) { if (!this.cronetNetworkChangeNotifier) { return; } this.cronetNetworkChangeNotifier.notifyConnected(handle.netId, r6, s6); this.cronetNetworkChangeNotifier.notifyTypeChanged(r6, handle.netId); } notifyCronetDisconnect(handle) { if (!this.cronetNetworkChangeNotifier) { return; } this.cronetNetworkChangeNotifier.notifyDisconnected(handle.netId, this.current_has_vpn); if (this.current_net_id === this.default_net_id) { this.cronetNetworkChangeNotifier.notifyTypeChanged(this.current_net_type, this.current_net_id); } } unregisterEvent() { this.defaultConnection.unregister((error) => { TTLogger.info(OhosNetworkLibrary.TAG, " unregister"); if (error) { TTLogger.info(OhosNetworkLibrary.TAG, " unregister error " + error); } }); } refreshDefaultNetState() { try { this.refreshProxy(); let m6 = connection.getDefaultNetSync(); TTLogger.info(OhosNetworkLibrary.TAG, JSON.stringify(m6) + " refreshDefaultNetState"); if (m6.netId !== 0) { let netCapabilities = connection.getNetCapabilitiesSync(m6); let n6 = this.hasVPN(netCapabilities); let o6 = this.isNetworkAvailable(netCapabilities); let p6 = this.getNetBearTypeFromNetCapabilities(netCapabilities); this.current_net_id = m6.netId; this.current_net_type = p6; this.current_availability = o6; this.current_has_vpn = n6; } else { this.current_net_id = this.default_net_id; this.current_net_type = this.default_net_type; this.current_availability = this.default_availability; this.current_has_vpn = this.default_has_vpn; } TTLogger.info(OhosNetworkLibrary.TAG, " refreshDefaultNetState done" + " | netid is " + this.current_net_id + " | type is " + this.current_net_type + " | connected is " + this.current_availability + " | proxy is " + this.current_proxy + " | hasVPN is " + this.current_has_vpn); } catch (e) { TTLogger.error(OhosNetworkLibrary.TAG, " refreshDefaultNetState error " + e); } } getNetBearTypeFromNetCapabilities(prop) { if (prop.bearerTypes.length === 0) { return ""; } let types = prop.bearerTypes; if (types.length === 1) { if (types[0] === connection.NetBearType.BEARER_CELLULAR) { return "CELLULAR"; } else if (types[0] === connection.NetBearType.BEARER_WIFI) { return "WIFI"; } else if (types[0] === connection.NetBearType.BEARER_ETHERNET) { return "ETHERNET"; } } else { return "NONE"; } return ""; } isNetworkAvailable(prop) { if (prop.networkCap?.length === 0) { return false; } if (prop.networkCap?.indexOf(16) === -1) { return false; } return true; } hasVPN(prop) { if (prop.networkCap?.length === 0) { return false; } if (prop.networkCap?.indexOf(15) === -1) { return false; } return true; } refreshProxy() { connection.getDefaultHttpProxy((error, proxy) => { if (error) { return; } if (!this.cronetNetworkChangeNotifier) { return; } let k6 = proxy.host + ":" + String(proxy.port); this.current_proxy = k6; TTLogger.debug(OhosNetworkLibrary.TAG, "get new proxy is " + this.current_proxy); const l6 = "http=" + proxy.host + ":" + proxy.port + ";https=" + proxy.host + ":" + proxy.port; TTLogger.debug("OhosNetworkLibrary, proxy config is " + l6); this.cronetNetworkChangeNotifier.notifyProxyChanged(l6); }); } async refreshAllNets() { try { let g6 = await connection.getAllNets(); this.current_all_nets.clear(); for (let h6 = 0; h6 < g6.length; h6++) { let handle = g6[h6]; let i6 = connection.getNetCapabilitiesSync(handle); let id = handle.netId; let type = this.getNetBearTypeFromNetCapabilities(i6); this.current_all_nets.set(id, type); TTLogger.debug(OhosNetworkLibrary.TAG, "get " + id + " " + type); } } catch (e) { throw new Error("refreshAllNets failed"); } } async getCurrentState() { this.refreshDefaultNetState(); try { await this.refreshAllNets(); } catch (e) { throw e; } let e6 = "netid is " + this.current_net_id + " \ntype is " + this.current_net_type + " \nconnected is " + this.current_availability + " \nproxy is " + this.current_proxy + " \nhasVPN is " + this.current_has_vpn + "\n"; e6 += "\n all net count is " + this.current_all_nets.size; this.current_all_nets.forEach((key, value) => { e6 += "\nid is " + key + " type is " + value; }); return e6; } onTNCConfigUpdate(d6) { if (!this.cronetNetworkChangeNotifier) { this.cronetNetworkChangeNotifier = new TTNetworkChangeNotifier(); } if (this.cronetNetworkChangeNotifier && this.isNotifyOnInit) { this.isNotifyOnInit = false; this.refreshDefaultNetState(); this.cronetNetworkChangeNotifier.notifyConnectionOnInit(this.current_net_type, this.current_net_id, this.current_has_vpn); } } } OhosNetworkLibrary.TAG = OhosNetworkLibrary.name; OhosNetworkLibrary.eventHistory = new List(); 