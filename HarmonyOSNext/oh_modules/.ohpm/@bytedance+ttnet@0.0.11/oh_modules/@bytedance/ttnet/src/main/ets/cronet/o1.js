import { HttpDataTypeEnum, TTHttpRequest } from '@bytedance/cronet/Index'; import { ResponseBodyTypeEnum } from "../ttnet/a/c"; import { SsResponse } from "../ttnet/i1/j1"; import { TTNetworkError } from "../ttnet/l"; import { CronetHttpClient } from "./k1"; import { Response } from "../ttnet/a/b"; import { Header } from "../ttnet/a/d"; import List from '@ohos.util.List'; import { CronetCookieManager } from "./s"; import webview from "@ohos.web.webview"; import { TTLogger } from "../ttnet/p/l1"; import { HttpUtils } from "../ttnet/p/m1"; import { TTJson } from "../ttnet/p/n1"; export class CronetCall { constructor(request) { this.httpRequest = new TTHttpRequest(); this.httpStatusCode = -1; this.responseHeaders = new List(); this.isDone = false; this.onRedirectCalled = false; this.isCanceled = false; this.originRequest = request; this.followRedirect = request.getRequestContext().followRedirect; this.options = this.createHttpRequestOptions(request); this.httpRequest.setEngine(CronetHttpClient.inst().getCronetEngine()); } createHttpRequestOptions(request) { const h3 = HttpUtils.convertHttpMethodToString(request.getMethod()); const headers = HttpUtils.checkAndAddUserAgent(request.getHeaders(), CronetCall.CRONET_USER_AGENT); return { expectDataType: this.convertBodyType(request.getResponseType()), method: h3, header: this.header2CronetHeader(headers), connectTimeout: request.getConnectTimeout(), readTimeout: request.getReadTimeout(), }; } getRequest() { return this.originRequest; } convertBodyType(type) { return type === ResponseBodyTypeEnum.STRING ? HttpDataTypeEnum.STRING : HttpDataTypeEnum.ARRAY_BUFFER; } header2CronetHeader(headers) { const g3 = []; for (const header of headers) { g3.push({ name: header.getName(), value: header.getValue() }); } return g3; } async addExtraData() { if (this.options.method !== "POST" && this.options.method !== "PUT") { return; } const body = this.originRequest.getRequestBody(); if (typeof body === 'string' && body.length > 0) { this.options.extraData = body; } else if (body instanceof ArrayBuffer && body.byteLength > 0) { this.options.extraData = body; } else if (typeof body === 'object' && body !== null) { const f3 = this.originRequest.getRequestBodyConverter(); this.options.extraData = f3 ? await f3.convertRequestBody(body) : TTJson.stringify(body); } else { this.options.extraData = HttpUtils.NULL_BODY_STRING; } } saveSetCookieFromTTHttpResponse(c3) { const d3 = c3.urlChain[c3.urlChain.length - 1]; const e3 = new List(); for (const header of c3.header) { e3.add(new Header(header.name, header.value)); } const response = new Response(d3, c3.httpStatusCode, e3, "", "", ""); CronetCookieManager.inst().saveSharedCookie(response); } async onRedirect(info) { this.onRedirectCalled = true; if (info) { const b3 = Date.now(); this.saveSetCookieFromTTHttpResponse(info.responseInfo); this.originRequest.getHttpRequestInfo().saveRedirectCookieDuration = Date.now() - b3; } if (!this.followRedirect) { this.cancel(); return; } if (!info) { this.httpRequest.followRedirect(); return; } TTLogger.debug(CronetCall.TAG, `setOnRedirectCallback : newLocationUrl: ${info.newLocationUrl}`); const u2 = info.responseInfo.urlChain[info.responseInfo.urlChain.length - 1]; const v2 = HttpUtils.safeCreateUri(u2); const w2 = HttpUtils.safeCreateUri(info.newLocationUrl); if (!v2 || !w2) { this.httpRequest.followRedirect(); return; } const z2 = v2.host === w2.host; TTLogger.debug(CronetCall.TAG, `last host is ${v2.host} new host is ${w2.host}`); if (!z2) { this.httpRequest.removeRequestCookieHeader(); const a3 = await webview.WebCookieManager.fetchCookie(info.newLocationUrl); this.httpRequest.addRequestCookieHeader("Cookie", a3); } this.httpRequest.followRedirect(); } onResponseStart(info) { if (!info) { return; } TTLogger.debug(CronetCall.TAG, `responseInfo: ${TTJson.stringify(info)}`); for (const header of info.header) { this.responseHeaders.add(new Header(header.name, header.value)); } this.httpStatusCode = info.httpStatusCode; const t2 = Date.now(); this.saveSetCookieFromTTHttpResponse(info); this.originRequest.getHttpRequestInfo().saveResponseCookieDuration = Date.now() - t2; } onSuccess(r2, body) { if (this.httpStatusCode < 200 || this.httpStatusCode >= 300) { const s2 = new TTNetworkError(`Response code is not 2xx: ${this.httpStatusCode}`); s2.setHttpStatusCode(this.httpStatusCode); s2.setRequestLog(r2); if (body) { s2.setResponseError(body); } return s2; } else { return new SsResponse(this.originRequest.getUrl(), this.httpStatusCode, this.responseHeaders, body || "", r2); } } onFail(info) { TTLogger.debug(CronetCall.TAG, `error: ${TTJson.stringify(info.error)}`); const q2 = new TTNetworkError(TTJson.stringify(info.error)); q2.setErrorMessage(info.error.message); q2.setNetErrorCode(info.error.internalErrorCode); q2.setRequestLog(info.requestLog); return q2; } onCancel(n2) { let o2; if (!this.followRedirect && this.onRedirectCalled) { o2 = new TTNetworkError(TTNetworkError.ERR_UNSUPPORTED_REDIRECT_MSG); o2.setNetErrorCode(TTNetworkError.ERR_UNSUPPORTED_REDIRECT_CODE); } else { o2 = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); o2.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); } o2.setRequestLog(n2); return o2; } async execute() { if (this.isCanceled) { throw this.createCanceledError(); } await this.addExtraData(); return new Promise((l2, m2) => { this.setupCallbacks(l2, m2); this.startRequest(m2); }); } executeInStreamCallback(callback) { if (this.isCanceled) { throw this.createCanceledError(); } this.setupStreamCallbacks(callback); this.startRequest(error => callback.onError(error)); } async executeUploadInStream(f2) { if (this.isCanceled) { throw this.createCanceledError(); } return new Promise((h2, i2) => { this.setupCallbacks(h2, i2); this.setupUploadReadCallback(f2); this.updateRequestHeadersWithOutput(f2); this.startRequest(i2); }); } executeBothInStream(d2, callback) { if (this.isCanceled) { throw this.createCanceledError(); } this.setupStreamCallbacks(callback); this.setupUploadReadCallback(d2); this.updateRequestHeadersWithOutput(d2); this.startRequest(error => callback.onError(error)); } setupCallbacks(s1, t1) { this.httpRequest.setOnRedirectCallback((info) => this.onRedirect(info)); this.httpRequest.setOnResponseStartCallback((info) => this.onResponseStart(info)); this.httpRequest.setOnSuccessCallback((c2, body) => { const result = this.onSuccess(c2, body); result instanceof TTNetworkError ? t1(result) : s1(result); this.setRequestEnd(); }); this.httpRequest.setOnFailCallback((info) => { t1(this.onFail(info)); this.setRequestEnd(); }); this.httpRequest.setOnCancelCallback((b2) => { t1(this.onCancel(b2)); this.setRequestEnd(); }); } setupStreamCallbacks(callback) { this.options.expectDataType = HttpDataTypeEnum.ARRAY_BUFFER; this.httpRequest.setOnRedirectCallback((info) => this.onRedirect(info)); this.httpRequest.setOnResponseStartCallback((info) => { this.onResponseStart(info); const response = new SsResponse(this.originRequest.getUrl(), this.httpStatusCode, this.responseHeaders, ""); callback.onHeaderComplete(response); }); this.httpRequest.setOnReadCompleteCallback((buffer) => { callback.onDataComplete(buffer); }); this.httpRequest.setOnSuccessCallback((q1) => { const response = new SsResponse(this.originRequest.getUrl(), this.httpStatusCode, this.responseHeaders, "", q1); callback.onSucceed(response); this.setRequestEnd(); }); this.httpRequest.setOnFailCallback((info) => { callback.onError(this.onFail(info)); this.setRequestEnd(); }); this.httpRequest.setOnCancelCallback((p1) => { callback.onError(this.onCancel(p1)); this.setRequestEnd(); }); } setupUploadReadCallback(g1) { this.httpRequest.setReadCallback(() => { g1.getBuffer(CronetCall.STREAM_BUFFER_MAX_SIZE).then((result) => { this.httpRequest.writeMore(result[0], result[1]); }); }); } updateRequestHeadersWithOutput(f1) { if (f1.mimeType().length > 0) { this.options.header?.push({ name: "content-type", value: f1.mimeType() }); } if (f1.length() > 0) { this.options.header?.push({ name: "content-length", value: f1.length().toString() }); } this.options.extraData = ""; } startRequest(b1) { const c1 = this.httpRequest.start(this.originRequest.getUrl(), this.options); if (c1 !== 0) { const d1 = CronetHttpClient.inst().getCronetEngine()?.getErrorString(c1) ?? "Unknown error"; const e1 = new TTNetworkError(`http request start failed: ${d1}`); e1.setNetErrorCode(c1); b1(e1); this.setRequestEnd(); } } setRequestEnd() { this.httpRequest.destroy(); this.isDone = true; } createCanceledError() { const error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); return error; } cancel() { this.isCanceled = true; if (!this.isDone) { this.httpRequest.cancel(); } } } CronetCall.TAG = CronetCall.name; CronetCall.CRONET_USER_AGENT = "cronet/1.0.0"; CronetCall.STREAM_BUFFER_MAX_SIZE = 5 * 1024 * 1024; 