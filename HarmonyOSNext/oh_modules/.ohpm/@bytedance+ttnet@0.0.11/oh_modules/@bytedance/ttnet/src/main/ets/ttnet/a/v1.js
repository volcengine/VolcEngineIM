import { ResponseBodyTypeEnum } from "./c"; import { Response } from "./b"; import { TTNetworkError } from "../l"; import { Header } from "./d"; import { BDTuringRetry } from "../g/h"; import { OhosResponseCallbackImpl } from "../../i/s1"; import { TTApiRequestMonitor } from "../g/k"; import { CronetResponseCallbackImpl } from "../../cronet/q1"; import { TTNetworkUtils } from "../f"; import { jsonConverter } from "./m"; import { CronetCookieManager } from "../../cronet/s"; import { AsyncTTNetInterceptor } from "../g/a1"; import { ClientKeyManager } from "../g/b1"; import { TTLogger } from "../p/l1"; import { HttpUtils } from "../p/m1"; import { TTJson } from "../p/n1"; export class SsHttpCall { constructor(request, a10, b10, connectTimeout, readTimeout, proxy, c10, caPath) { this.logId = ""; this.isRequestCanceled = false; this.isRequestExecuted = false; this.shouldBypassBdturingRetry = false; this.bdturingRetryEnabled = false; this.isRequestReported = false; this.requestInterceptors = a10; this.responseInterceptors = b10; this.client = c10; request = request.newBuilder(request.getUrl()) .setHttpProxy(proxy) .setCaPath(caPath) .setConnectTimeout(connectTimeout) .setReadTimeout(readTimeout) .build(); this.originRequest = request; let d10 = this.originRequest.getFirstHeader(BDTuringRetry.BDTURING_BYPASS_HEADER); if (d10 != null && d10.getValue() === "1") { this.shouldBypassBdturingRetry = true; } } isExecuted() { return this.isRequestExecuted; } isCanceled() { return this.isRequestCanceled; } cancel() { if (this.originCall) { this.originCall.cancel(); } this.isRequestCanceled = true; } request() { return this.originRequest; } async shouldRetryCurrentRequest(headers) { let z9 = BDTuringRetry.getRetryRequestCallback(); if (z9) { try { let result = await z9.onCallToRetryRequestByTuringHeader(headers); if (result.isRequestRetryEnabled()) { this.originRequest = this.updateOriginRequest(result.getAddRequestHeaders()); return this.client.newSsCall(this.originRequest); } } catch (e) { throw new Error("shouldRetryCurrentRequest failed"); } } return null; } updateOriginRequest(x9) { let headers = this.originRequest.getHeaders(); headers.add(new Header(BDTuringRetry.BDTURING_RETRY_HEADER, "1")); if (x9.size > 0) { x9.forEach((value, key) => { headers.add(new Header(key, value)); }); } return this.originRequest.newBuilder(this.originRequest.getUrl()).requestHeaders(headers).build(); } async prepareRequestBeforeExecute() { if (this.isRequestCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); throw error; } if (!this.originRequest.isPureRequest()) { this.requestInterceptors.forEach(element => { this.originRequest = element.intercept(this.originRequest); }); let interceptors = AsyncTTNetInterceptor.getRequestInterceptors(); for (const w9 of interceptors) { this.originRequest = await w9.intercept(this.originRequest); } this.isRequestExecuted = true; } let request = this.originRequest; try { if (CronetCookieManager.inst().getEnableCookieWithDispatch()) { let u9 = Date.now(); let result = await TTNetworkUtils.urlDispatch(this.originRequest.getUrl()); this.originRequest.getHttpRequestInfo().dispatchForCookieDuration = Date.now() - u9; request = await CronetCookieManager.inst().addCookieHeaderToRequest(this.originRequest, result.finalUrl); } else { request = await CronetCookieManager.inst().addCookieHeaderToRequest(this.originRequest, ""); } } catch (error) { TTLogger.error(SsHttpCall.TAG, " catch error: " + error); } if (this.isRequestCanceled) { let error = new TTNetworkError(TTNetworkError.ERR_CANCELED_BY_USER); error.setNetErrorCode(TTNetworkError.ERR_CANCELED_CODE); throw error; } ClientKeyManager.getInstance().addClientKeyHeader(request); return request; } async processResponseAfterExecute(response) { ClientKeyManager.getInstance().UpdateClientKeyAndSessionInfo(response); this.responseInterceptors.forEach(element => { response = element.intercept(this.originRequest, response); }); let interceptors = AsyncTTNetInterceptor.getResponseInterceptors(); for (const t9 of interceptors) { response = await t9.intercept(this.originRequest, response); } return response; } async handleResponseBody(response) { const o9 = this.originRequest.getResponseBodyConverter(); let p9 = response.getResponseBody(); const q9 = this.originRequest.getHttpRequestInfo(); const startTime = Date.now(); try { if (o9 && response.getResponseBody() instanceof ArrayBuffer) { p9 = await o9.covertResponseBody(response.getResponseBody()); } else if (this.originRequest.getResponseType() === ResponseBodyTypeEnum.JSON) { if (response.getResponseBody() instanceof ArrayBuffer) { p9 = await jsonConverter.covertResponseBody(response.getResponseBody()); } else { p9 = TTJson.parse(String(response.getResponseBody())); } } q9.covertDuration = Date.now() - startTime; return p9; } catch (error) { const r9 = new TTNetworkError("Response body conversion failed."); r9.setOriginalError(error); r9.setRequestLog(response.getRequestLog()); r9.setHttpStatusCode(response.getStatusCode()); r9.setResponseError(response.getResponseBody()); throw r9; } } async execute() { const k9 = this.originRequest.getHttpRequestInfo(); k9.startTime = Date.now(); try { this.originRequest = await this.prepareRequestBeforeExecute(); this.originCall = this.client.newSsCall(this.originRequest); this.response = await this.originCall.execute(); let headers = this.parseHeaders(this.response.getHttpHeaders()); if (this.bdturingRetryEnabled) { const n9 = await this.shouldRetryCurrentRequest(headers); if (n9) { TTLogger.debug(SsHttpCall.TAG, ' retry current request.'); this.originCall = n9; this.response = await n9.execute(); headers = this.parseHeaders(this.response.getHttpHeaders()); } } const m9 = await this.handleResponseBody(this.response); let response = new Response(this.originRequest.getUrl(), this.response.getStatusCode(), headers, m9, this.logId, this.response.getRequestLog()); response = await this.processResponseAfterExecute(response); this.monitorApiOk(response); return response; } catch (err) { const l9 = this.createTTNetworkError(err, this.response); this.monitorApiError(l9); throw l9; } } generateRequestCommonInfo(j9) { j9.url = this.originRequest.getUrl(); j9.computeRequestDuration(); j9.method = HttpUtils.convertHttpMethodToString(this.originRequest.getMethod()); j9.generateApiData(); } monitorApiOk(response) { let monitor = TTApiRequestMonitor.getApiRequestMonitor(); if (!monitor) { return; } if (this.isRequestReported) { TTLogger.debug(SsHttpCall.TAG, `isRequestReported: ${this.isRequestReported}`); return; } let i9 = this.originRequest.getHttpRequestInfo(); i9.isApiOk = true; i9.httpCode = response.getHttpStatusCode(); i9.logId = response.getLogId(); i9.responseHeaders = response.getHeaders(); i9.requestLog = response.getRequestLog(); this.generateRequestCommonInfo(i9); TTLogger.debug(SsHttpCall.TAG, "NetworkTag: " + i9.toString()); monitor.monitorApiOk(i9); this.isRequestReported = true; } monitorApiError(err) { let monitor = TTApiRequestMonitor.getApiRequestMonitor(); if (!monitor) { return; } if (this.isRequestReported) { TTLogger.debug(SsHttpCall.TAG, `isRequestReported: ${this.isRequestReported}`); return; } let h9 = this.originRequest.getHttpRequestInfo(); h9.isApiOk = false; h9.netError = err.getNetErrorCode(); h9.httpCode = err.getHttpStatusCode(); h9.errMsg = err.getErrorMessage(); h9.requestLog = err.getRequestLog(); this.generateRequestCommonInfo(h9); TTLogger.debug(SsHttpCall.TAG, "NetworkTag: " + h9.toString()); monitor.monitorApiError(h9); this.isRequestReported = true; } async executeInStreamCallback(callback) { const f9 = this.originRequest.getHttpRequestInfo(); f9.startTime = Date.now(); try { this.originRequest = await this.prepareRequestBeforeExecute(); this.originCall = this.client.newSsCall(this.originRequest); if (TTNetworkUtils.isCronetEnabled()) { this.originCall.executeInStreamCallback(new CronetResponseCallbackImpl(callback, this)); } else { this.originCall.executeInStreamCallback(new OhosResponseCallbackImpl(callback, this)); } } catch (err) { const g9 = this.createTTNetworkError(err, this.response); this.monitorApiError(g9); throw g9; } } async executeUploadInStream(b9) { const c9 = this.originRequest.getHttpRequestInfo(); c9.startTime = Date.now(); try { this.originRequest = await this.prepareRequestBeforeExecute(); this.originCall = this.client.newSsCall(this.originRequest); this.response = await this.originCall.executeUploadInStream(b9); let headers = this.parseHeaders(this.response.getHttpHeaders()); const e9 = await this.handleResponseBody(this.response); let response = new Response(this.originRequest.getUrl(), this.response.getStatusCode(), headers, e9, this.logId, this.response.getRequestLog()); response = await this.processResponseAfterExecute(response); this.monitorApiOk(response); return response; } catch (err) { const d9 = this.createTTNetworkError(err, this.response); this.monitorApiError(d9); throw d9; } } async executeBothInStream(z8, callback) { try { this.originRequest = await this.prepareRequestBeforeExecute(); this.originCall = this.client.newSsCall(this.originRequest); if (TTNetworkUtils.isCronetEnabled()) { this.originCall.executeBothInStream(z8, new CronetResponseCallbackImpl(callback, this)); } else { this.originCall.executeBothInStream(z8, new OhosResponseCallbackImpl(callback, this)); } } catch (err) { const a9 = this.createTTNetworkError(err, this.response); this.monitorApiError(a9); throw a9; } } createTTNetworkError(err, response) { let y8; if (err instanceof TTNetworkError) { y8 = err; } else { y8 = new TTNetworkError(err.message); y8.setOriginalError(err); if (response) { y8.setHttpStatusCode(response.getStatusCode()); y8.setRequestLog(response.getRequestLog()); y8.setResponseError(response.getResponseBody()); } } return y8; } parseHeaders(headers) { headers.forEach((value) => { if (value.getName().toLowerCase() === SsHttpCall.LOGID) { this.logId = value.getValue(); } if (!this.shouldBypassBdturingRetry && value.getName().toLowerCase() === BDTuringRetry.BDTURING_VERIFY_HEADER) { this.bdturingRetryEnabled = true; } }); return headers; } getUrl() { return this.originRequest.getUrl(); } getLodId() { return this.logId; } } SsHttpCall.TAG = SsHttpCall.name; SsHttpCall.LOGID = "x-tt-logid"; 