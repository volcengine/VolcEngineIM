import { TypedOutput } from "./u"; import { str2ab } from "../p/y1"; import util from "@ohos.util"; import { TTLogger } from "../p/l1"; export class MimePart { constructor(name, n13, body, o13, isFirst) { this.isBuilt = false; this.isBoundaryAndHeaderRead = false; this.name = name; this.transferEncoding = n13; this.body = body; this.isFirst = isFirst; this.boundary = o13; } async getBuffer(maxSize) { this.build(); let d13 = new ArrayBuffer(maxSize); const e13 = new Uint8Array(d13); let f13 = maxSize; let index = 0; if (!this.isBoundaryAndHeaderRead) { if (this.partBoundary) { let l13 = new Uint8Array(this.partBoundary); for (let m13 = 0; m13 < this.partBoundary.byteLength; m13++) { e13[index++] = l13[m13]; } f13 -= this.partBoundary.byteLength; } if (this.partHeader) { let j13 = new Uint8Array(this.partHeader); for (let k13 = 0; k13 < this.partHeader.byteLength; k13++) { e13[index++] = j13[k13]; } f13 -= this.partHeader.byteLength; } this.isBoundaryAndHeaderRead = true; } if (f13 <= 0) { return [d13, true]; } try { let result = await this.body.getBuffer(f13); let g13 = result[0]; let h13 = new Uint8Array(g13); for (let i13 = 0; i13 < g13.byteLength; i13++) { e13[index++] = h13[i13]; } d13 = d13.slice(0, index); TTLogger.debug(MimePart.TAG, "mimepart last ? " + result[1]); return [d13, result[1]]; } catch (e) { TTLogger.info(MimePart.TAG, "getBuffer failed"); } d13 = d13.slice(0, index); return [d13, true]; } size() { this.build(); let b13 = this.body.length(); if (b13 > -1) { let c13 = 0; if (this.partBoundary) { c13 += this.partBoundary.byteLength; } if (this.partHeader) { c13 += this.partHeader.byteLength; } c13 += b13; return c13; } else { return -1; } } build() { if (this.isBuilt) { return; } this.partBoundary = MultipartTypedOutput.buildBoundary(this.boundary, this.isFirst, false); this.partHeader = MultipartTypedOutput.buildHeader(this.name, this.transferEncoding, this.body); this.isBuilt = true; } } MimePart.TAG = MimePart.name; export class MultipartTypedOutput extends TypedOutput { constructor(a13) { super(); this.mimeParts = []; this.currentUploadPartIndex = 0; this.currentUploadCount = 0; if (a13) { this.boundary = a13; } else { this.boundary = util.generateRandomUUID(); } this.footer = MultipartTypedOutput.buildBoundary(this.boundary, false, true); this.totalLength = this.footer.byteLength; } addPart(name, body) { this.addPartWithDetail(name, MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING, body); } addPartWithDetail(name, y12, body) { let z12 = new MimePart(name, y12, body, this.boundary, this.mimeParts.length === 0); this.mimeParts.push(z12); let size = z12.size(); if (size == -1) { this.totalLength = -1; } else if (this.totalLength != -1) { this.totalLength += size; } } mimeType() { return "multipart/form-data; boundary=" + this.boundary; } length() { return this.totalLength; } async getBuffer(maxSize) { let p12 = new ArrayBuffer(maxSize); let q12 = new Uint8Array(p12); let index = 0; this.currentUploadCount = 0; for (let r12 = this.currentUploadPartIndex; r12 < this.mimeParts.length; ++r12) { TTLogger.debug(MultipartTypedOutput.TAG, "multipart index " + r12); try { let result = await this.mimeParts[r12].getBuffer(maxSize - this.currentUploadCount); let s12 = result[0]; let t12 = new Uint8Array(s12); TTLogger.debug(MultipartTypedOutput.TAG, "multipart get part length " + s12.byteLength); for (let x12 = 0; x12 < s12.byteLength; x12++) { q12[index++] = t12[x12]; } this.currentUploadCount += s12.byteLength; let u12 = result[1]; if (u12) { this.currentUploadPartIndex = r12 + 1; } if (this.currentUploadPartIndex >= this.mimeParts.length) { let v12 = new Uint8Array(this.footer); for (let w12 = 0; w12 < this.footer.byteLength; w12++) { q12[index++] = v12[w12]; } break; } if (this.currentUploadCount >= maxSize) { break; } } catch (e) { TTLogger.info(MultipartTypedOutput.TAG, "getBuffer failed"); } } p12 = p12.slice(0, index); return [p12, this.currentUploadPartIndex >= this.mimeParts.length]; } static buildBoundary(n12, first, last) { let o12 = ""; if (!first) { o12 += "\r\n"; } o12 += "--"; o12 += n12; if (last) { o12 += "--"; } o12 += "\r\n"; return str2ab(o12); } static buildHeader(name, m12, value) { let headers = ""; headers += "Content-Disposition: form-data; name=\""; headers += name; let fileName = value.fileName(); if (fileName.length > 0) { headers += "\"; filename=\""; headers += fileName; } headers += "\"\r\nContent-Type: "; headers += value.mimeType(); let length = value.length(); if (length != -1) { headers += "\r\nContent-Length: " + length; } headers += "\r\nContent-Transfer-Encoding: "; headers += m12; headers += "\r\n\r\n"; return str2ab(headers); } } MultipartTypedOutput.TAG = MultipartTypedOutput.name; MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING = "binary"; 