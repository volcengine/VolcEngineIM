import { TypedOutput } from "./u"; import fs from '@ohos.file.fs'; import { TTLogger } from "../p/l1"; import taskpool from "@ohos.taskpool"; async function u13(fd, length, offset) { "use concurrent"; TTLogger.debug("ReadFile", `fd: ${fd}, length: ${length}, offset: ${offset}`); try { const w13 = new ArrayBuffer(length); const x13 = await fs.read(fd, w13, { offset: offset }); return w13.slice(0, x13); } catch (err) { TTLogger.error("ReadFile", `error: ${err}`); return new ArrayBuffer(0); } } export class TypedFile extends TypedOutput { constructor(fileName, v13, mimeType = 'application/octet-stream') { super(); this.readIndex = 0; this.uploadFileName = fileName; this.uploadFileLength = v13; this.contentType = mimeType; } fileName() { return this.uploadFileName; } mimeType() { return this.contentType; } length() { return this.uploadFileLength; } async getBuffer(maxSize) { try { if (this.uploadFileLength < 0) { const stat = await fs.stat(this.uploadFileName); this.uploadFileLength = stat.size; } if (!this.uploadFile) { this.uploadFile = await fs.open(this.uploadFileName, fs.OpenMode.READ_ONLY); } const task = new taskpool.Task(u13, this.uploadFile.fd, maxSize, this.readIndex); const result = await taskpool.execute(task); if (result.byteLength > 0) { this.readIndex += result.byteLength; if (this.readIndex < this.uploadFileLength) { return [result, false]; } else { fs.close(this.uploadFile); return [result, true]; } } } catch (error) { TTLogger.info(TypedFile.TAG, `getBuffer failed :${error}`); } fs.close(this.uploadFile); return [new ArrayBuffer(0), true]; } } TypedFile.TAG = TypedFile.name; 