import List from '@ohos.util.List'; import { Request } from "./c"; import { Response } from "./b"; import { ClientProvider, RequestInterceptor, ResponseInterceptor } from "./e"; import { Call } from "./t1"; import { TTNetworkError } from "../l"; import { Header } from "./d"; import connection from '@ohos.net.connection'; import { TTResponseCallback } from "../n"; import { TypedOutput } from "../t/u"; import { SsResponse } from "../i1/j1"; export declare class SsHttpCall implements Call { private static readonly TAG; private static readonly LOGID; private originRequest; private originCall?; private requestInterceptors; private responseInterceptors; private client; private logId; private isRequestCanceled; private isRequestExecuted; private shouldBypassBdturingRetry; private bdturingRetryEnabled; private isRequestReported; private response?; constructor(request: Request, a10: List<RequestInterceptor>, b10: List<ResponseInterceptor>, connectTimeout: number, readTimeout: number, proxy: connection.HttpProxy | boolean, c10: ClientProvider, caPath: string); isExecuted(): boolean; isCanceled(): boolean; cancel(): void; request(): Request; private shouldRetryCurrentRequest; private updateOriginRequest; private prepareRequestBeforeExecute; processResponseAfterExecute(response: Response): Promise<Response>; private handleResponseBody; execute(): Promise<Response<string | object | ArrayBuffer>>; private generateRequestCommonInfo; monitorApiOk(response: Response): void; monitorApiError(err: TTNetworkError): void; executeInStreamCallback(callback: TTResponseCallback): Promise<void>; executeUploadInStream(b9: TypedOutput): Promise<Response<string | object | ArrayBuffer>>; executeBothInStream(z8: TypedOutput, callback: TTResponseCallback): Promise<void>; createTTNetworkError(err: Error, response?: SsResponse): TTNetworkError; parseHeaders(headers: List<Header>): List<Header>; getUrl(): string; getLodId(): string; } 