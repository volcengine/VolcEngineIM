import { isNetworkAvailableFast } from "../u1/p2"; import Topic from "../k/l"; import { KEY_GEN_TIME, KEY_HEADER, KEY_MAGIC, KEY_MAGIC_VALUE } from "../o1/p1/q1"; import { currentTimeMillis } from "../k1/k2"; import { mapToRecord } from "../k1/r1"; import { buildRequest } from "../u1/s2"; export class BaseWorker { constructor(j20, k20) { this.lastDelayTaskId = -1; this.failCount = 0; this.sdkContext = j20; this.workerLoggerTag = k20; } isWorkerAutoStart() { return true; } prepareWork() { this.sdkContext.appLogLogger() .debug("{} prepareWork autoStart: {}", this.workerLoggerTag, this.getWorkName(), this.isWorkerAutoStart()); if (!this.isWorkerAutoStart()) { return; } this.sdkContext.dispatcher().stickyOnce(Topic.DidReady, () => { this.sdkContext.appLogLogger() .debug("{} prepareWork DidReady", this.workerLoggerTag, this.getWorkName()); this.requestWorker(); }); } requestWorker() { if (!isNetworkAvailableFast()) { this.sdkContext.appLogLogger() .warn("Not net availableï¼Œ{} not requested, try again later", this.workerLoggerTag, this.getWorkName()); this.waitNetAvailableRequestAgain(); return; } this.sdkContext.appLogLogger().info("{} start request", this.workerLoggerTag, this.getWorkName()); let g20 = this.buildRequestBody(); this.sdkContext.networkClient() .execute(buildRequest(this.getRequestUrl(), g20)) .then((i20) => { this.sdkContext.appLogLogger() .info("{} request return {}", this.workerLoggerTag, this.getWorkName(), i20); this.parseResponse(i20); }) .catch((h20) => { this.sdkContext.appLogLogger() .error("{} request returns exception", h20, this.workerLoggerTag, this.getWorkName()); this.requestWorkFailed(); }); } waitNetAvailableRequestAgain() { this.sdkContext.dispatcher().once(Topic.NetworkAvailable, () => { this.sdkContext.appLogLogger().debug("{} net available request try again", this.workerLoggerTag, this.getWorkName()); this.requestWorker(); }); } buildRequestBody() { let f20 = {}; f20[KEY_MAGIC] = KEY_MAGIC_VALUE; f20[KEY_HEADER] = mapToRecord(this.sdkContext.headerManager().getHeader()); f20[KEY_GEN_TIME] = currentTimeMillis(); return JSON.stringify(f20); } requestWorkFailed() { this.postDelayRequestWork(this.getFailInterval()); this.failCount++; } getFailInterval() { let d20 = this.getRetryIntervals(); let e20 = this.failCount % d20.length; return d20[e20]; } postDelayWork(b20, c20) { this.clearDelayTask(); this.lastDelayTaskId = setTimeout(() => { b20(); this.lastDelayTaskId = -1; }, c20); } clearDelayTask() { if (this.lastDelayTaskId != -1) { clearTimeout(this.lastDelayTaskId); } } postDelayRequestWork(a20) { this.sdkContext.appLogLogger() .debug("PostDelayRequestWork {} delay: {}ms", this.workerLoggerTag, this.getWorkName(), a20); this.postDelayWork(() => { this.requestWorker(); }, a20); } } export const RETRY_EMPTY = [ 2 * 1000, 10 * 1000, 10 * 1000, 20 * 1000, 20 * 1000, 60 * 1000, 60 * 1000, 2 * 60 * 1000, 2 * 60 * 1000, 3 * 60 * 1000, 3 * 60 * 1000, 6 * 60 * 1000, 6 * 60 * 1000, 9 * 60 * 1000, 9 * 60 * 1000 ]; export const RETRY_DIFF = [ 60 * 1000, 60 * 1000, 60 * 1000, 2 * 60 * 1000, 2 * 60 * 1000, 3 * 60 * 1000, 3 * 60 * 1000, 6 * 60 * 1000, 6 * 60 * 1000, 9 * 60 * 1000, 9 * 60 * 1000 ]; export const RETRY_SAME = [ 3 * 60 * 1000, 3 * 60 * 1000, 6 * 60 * 1000, 6 * 60 * 1000, 9 * 60 * 1000, 9 * 60 * 1000, 12 * 60 * 1000, 12 * 60 * 1000 ]; 