import Topic from "../../k/l"; import { KEY_AID, KEY_BD_DID, KEY_DEVICE_INFO_FROM, KEY_DID_FROM_REMOTE, KEY_GEN_TIME, KEY_HEADER, KEY_INSTALL_ID, KEY_INSTALL_ID_STR, KEY_MAGIC, KEY_MAGIC_VALUE, KEY_REGISTER_TIME, KEY_SSID, KEY_USER_UNIQUE_ID, KEY_USER_UNIQUE_ID_TYPE } from "../p1/q1"; import LoggerTag from "../../h1/j1"; import { checkDidValid, getDidInfo, isHeaderDidReady } from "../../k1/v2"; import { calcTimeDifference, currentTimeMillis, isTimeUp, TimeUnit } from "../../k1/k2"; import { BaseWorker, RETRY_EMPTY, RETRY_SAME } from "../../a2/g2"; import { isEmpty, strEquals } from "../../k1/l1"; import { isNetworkAvailableFast } from "../../u1/p2"; import { mapToRecord } from "../../k1/r1"; import { buildRequest } from "../../u1/s2"; import BuildProfile from "../../../../../../a"; export default class RegisterWorker extends BaseWorker { constructor(o6) { super(o6, LoggerTag.REGISTER); } getWorkName() { return RegisterWorker.workName; } prepareWork() { let m6 = this.sdkContext.headerManager().getValue(KEY_REGISTER_TIME, 0); if (isTimeUp(m6, 6, TimeUnit.HOUR)) { this.sdkContext.appLogLogger().info("Device register deal stat", LoggerTag.REGISTER); this.requestWorker(); } else { let n6 = calcTimeDifference(m6, 6, TimeUnit.HOUR); this.sdkContext.appLogLogger().debug("Device register deal delay: {}ms", LoggerTag.REGISTER, n6); this.postDelayRequestWork(n6); } this.monitorSSIDChange(); this.monitorUriRunTimeChange(); } monitorSSIDChange() { this.sdkContext.dispatcher().on(Topic.SSIDChange, (k6) => { let l6 = k6[KEY_SSID]; if (isEmpty(l6)) { this.sdkContext.appLogLogger().info("Receive ssid clear, start register", LoggerTag.REGISTER); this.requestWorker(); } }); } monitorUriRunTimeChange() { this.sdkContext.dispatcher().stickyOn(Topic.UriRunTimeChange, () => { this.sdkContext.appLogLogger().info("Device register deal stat, when uri runtime change", LoggerTag.REGISTER); this.requestWorker(); }); } getRequestUrl() { return this.sdkContext.runtimeUriConfig.getRegisterUri() .concat(`?${KEY_AID}=${this.sdkContext.sdkConfig().getAppId()}`); } parseResponse(e6) { if (e6) { let f6 = JSON.parse(e6.result); let g6 = f6[KEY_BD_DID] ?? ""; let h6 = isEmpty(f6[KEY_INSTALL_ID_STR]) ? f6[KEY_INSTALL_ID] + "" : f6[KEY_INSTALL_ID_STR]; if (BuildProfile.isSDKSsidMaintain) { let i6 = f6[KEY_SSID] ?? ""; if (checkDidValid(g6, i6)) { let j6 = this.sdkContext.headerManager().getValue(KEY_SSID, ""); this.sdkContext.headerManager().updateHeader(KEY_BD_DID, f6[KEY_BD_DID], true); this.sdkContext.headerManager().updateHeader(KEY_SSID, f6[KEY_SSID], true); this.sdkContext.headerManager().updateHeader(KEY_INSTALL_ID, h6, true); this.sdkContext.headerManager().updateHeader(KEY_REGISTER_TIME, currentTimeMillis(), true); this.notifyRemoteDidGet(); this.checkSsidChange(j6, i6); } else { this.sdkContext.appLogLogger() .warn("Device register response parse failed, did invalid {}", LoggerTag.REGISTER, e6); this.requestWorkFailed(); } } else { if (checkDidValid(g6)) { this.sdkContext.headerManager().updateHeader(KEY_BD_DID, f6[KEY_BD_DID], true); this.sdkContext.headerManager().updateHeader(KEY_INSTALL_ID, h6, true); this.sdkContext.headerManager().updateHeader(KEY_REGISTER_TIME, currentTimeMillis(), true); this.notifyRemoteDidGet(); } else { this.sdkContext.appLogLogger() .warn("Device register response parse failed, did invalid {}", LoggerTag.REGISTER, e6); this.requestWorkFailed(); } } } else { this.sdkContext.appLogLogger() .warn("Device register response parse failed, {}", LoggerTag.REGISTER, e6); this.requestWorkFailed(); } } checkSsidChange(b6, c6) { if (!strEquals(b6, c6)) { let d6 = {}; d6[KEY_SSID] = c6; this.sdkContext.dispatcher().emit(Topic.SSIDChange, d6); } } notifyRemoteDidGet() { let a6 = getDidInfo(this.sdkContext); a6[KEY_DEVICE_INFO_FROM] = KEY_DID_FROM_REMOTE; this.sdkContext.dispatcher().emit(Topic.DidReady, a6); this.sdkContext.appLogLogger().info("Remote deviceInfo -> {}", LoggerTag.REGISTER, a6); } getRetryIntervals() { if (isHeaderDidReady(this.sdkContext.headerManager())) { return RETRY_SAME; } else { return RETRY_EMPTY; } } async fetchSsidFromRemote(s5, t5) { if (!isNetworkAvailableFast()) { this.sdkContext.appLogLogger() .warn("Not net availableï¼Œ{} not fetchSsidFromRemote, try again later", this.workerLoggerTag, this.getWorkName()); this.waitNetAvailableRequestAgain(); return null; } this.sdkContext.appLogLogger().info("{} start fetchSsidFromRemote", this.workerLoggerTag, this.getWorkName()); let u5 = new Map(this.sdkContext.headerManager().getHeader()); u5.set(KEY_USER_UNIQUE_ID, s5); if (t5) { u5.set(KEY_USER_UNIQUE_ID_TYPE, t5); } let v5 = {}; v5[KEY_MAGIC] = KEY_MAGIC_VALUE; v5[KEY_HEADER] = mapToRecord(u5); v5[KEY_GEN_TIME] = currentTimeMillis(); try { let x5 = await this.sdkContext.networkClient() .execute(buildRequest(this.getRequestUrl(), JSON.stringify(v5))); this.sdkContext.appLogLogger() .info("{} fetchSsidFromRemote return {}", this.workerLoggerTag, this.getWorkName(), x5); if (x5) { let y5 = JSON.parse(x5.result); let z5 = y5[KEY_SSID] ?? ""; this.sdkContext.appLogLogger() .info("{} fetchSsidFromRemote success, uuid: {}, ssid: {}", this.workerLoggerTag, this.getWorkName(), s5, z5); return z5; } } catch (w5) { this.sdkContext.appLogLogger() .error("{} fetchSsidFromRemote returns exception", w5, this.workerLoggerTag, this.getWorkName()); } return null; } } RegisterWorker.workName = 'work:register'; 