import { BaseWorker } from "../a2/g2"; import LoggerTag from "../h1/j1"; import { CongestionController } from "../u1/r2"; import EventType from "./j"; import { KEY_AID, KEY_EVENT, KEY_GEN_TIME, KEY_HEADER, KEY_LAUNCH, KEY_LOCAL_TIME, KEY_MAGIC, KEY_MAGIC_VALUE, KEY_SSID, KEY_TERMINATE, KEY_USER_UNIQUE_ID } from "../o1/p1/q1"; import { currentTimeMillis } from "../k1/k2"; import { checkIfJamMsg, checkResponseOk, isNetworkAvailableFast } from "../u1/p2"; import Topic from "../k/l"; import { BLOCK_LIST, CONFIG, EVENT_LIST_V3 } from "../e2/f2"; import { isArrayEmpty, mapToRecord } from "../k1/r1"; import { buildRequest } from "../u1/s2"; import { isEmpty, isNotEmpty, strEquals } from "../k1/l1"; import RegisterWorker from "../o1/t2/u2"; import BuildProfile from "../../../../../a"; import { isHeaderDidReady } from "../k1/v2"; export const EVENT_INTERVAL_DEFAULT = 15 * 1000; const n2 = 10 * 1000; export const RETRY_INTERVALS = [n2]; const o2 = "message"; const p2 = "success"; export class Sender extends BaseWorker { constructor(n4) { super(n4, LoggerTag.SENDER); this.eventInterval = EVENT_INTERVAL_DEFAULT; this.workName = 'work:sender'; this.congestionController = new CongestionController(n4); } prepareWork() { super.prepareWork(); this.sdkContext.dispatcher().on(Topic.RemoteConfigGet, (m4) => { if (m4) { this.eventInterval = m4[CONFIG].eventInterval * 1000 ?? EVENT_INTERVAL_DEFAULT; this.sdkContext.appLogLogger() .debug("{} remoteConfigGet update eventInterval: {}ms", LoggerTag.SENDER, this.getWorkName(), this.eventInterval); } }); this.registerAppLogApplicationStateChangeCallback(this.sdkContext, this); } registerAppLogApplicationStateChangeCallback(k4, l4) { k4.context().getApplicationContext().on("applicationStateChange", { onApplicationForeground() { }, onApplicationBackground() { if (isHeaderDidReady(l4.sdkContext.headerManager())) { l4.sdkContext.appLogLogger().info("Sender request onApplicationBackground", LoggerTag.SENDER); l4.postDelayRequestWork(0); } else { l4.sdkContext.appLogLogger().warn("Sender request onApplicationBackground failed, header not ready.", LoggerTag.SENDER); } } }); } getWorkName() { return this.workName; } getRequestUrl() { return this.sdkContext.runtimeUriConfig.getSendUris()[0]; } async requestWorker() { if (!isNetworkAvailableFast()) { this.sdkContext.appLogLogger() .warn("Not net availableï¼Œ{} not requested, try again later", this.workerLoggerTag, this.getWorkName()); this.waitNetAvailableRequestAgain(); return; } if (!this.congestionController.isCanSend()) { this.sdkContext.appLogLogger().warn("Send events failed, target CongestionController", LoggerTag.SENDER); return; } this.sdkContext.appLogLogger().info("{} start request", LoggerTag.SENDER, this.getWorkName()); if (await this.sendEventPack()) { this.sdkContext.appLogLogger() .info("{} sendEventPack success", LoggerTag.SENDER, this.getWorkName()); this.postDelayRequestWork(this.eventInterval); } else { this.sdkContext.appLogLogger() .warn("{} sendEventPack failed", LoggerTag.SENDER, this.getWorkName()); this.requestWorkFailed(); } } async sendEventPack() { let v3 = await this.sdkContext.eventProcessor() .getEventDbStore().queryEvents(); if (v3.length == 0) { this.sdkContext.appLogLogger() .info("{} send wait next time, because queryEvents empty", LoggerTag.SENDER, this.getWorkName()); return true; } let w3 = v3.filter((j4) => { return j4.eventType == EventType.LAUNCH; }).map((i4) => { return i4.convertToJson(); }); let x3 = v3.filter((h4) => { return h4.eventType == EventType.TERMINATE; }).map((g4) => { return g4.convertToJson(); }); let y3 = v3.filter((f4) => { return f4.eventType == EventType.EVENT; }).map((e4) => { return e4.convertToJson(); }); let z3 = []; await checkEventSsidReady(z3.concat(w3, x3, y3), this.sdkContext, this.workName); this.sdkContext.appLogLogger() .info("{} queryEvents: {}, launchList: {}, termList: {}, eventList: {}", LoggerTag.SENDER, this.getWorkName(), v3.length, w3.length, x3.length, y3.length); for (let a4 of this.sdkContext.runtimeUriConfig.getSendUris()) { a4 = a4.concat(`?${KEY_AID}=${this.sdkContext.sdkConfig().getAppId()}`); let b4 = this.buildEventRequestBody(w3, x3, y3); try { let d4 = await this.sdkContext.networkClient() .execute(buildRequest(a4, b4)); this.sdkContext.appLogLogger() .info("{} request return {}", LoggerTag.SENDER, this.getWorkName(), d4); if (checkResponseOk(d4)) { this.sdkContext.appLogLogger() .info("{} Response Ok", LoggerTag.SENDER, this.getWorkName()); await (this.sdkContext.eventProcessor().getEventDbStore()).deleteEvents(v3); this.congestionController.handleSuccess(); this.parseResponse(d4); return true; } else if (checkIfJamMsg(d4)) { this.sdkContext.appLogLogger() .info("{} Response Jam", LoggerTag.SENDER, this.getWorkName()); this.congestionController.handleException(); return true; } else { this.sdkContext.appLogLogger() .info("{} Response Failed: {}", LoggerTag.SENDER, this.getWorkName(), d4); } } catch (c4) { this.sdkContext.appLogLogger() .error("{} request returns exception", c4, LoggerTag.SENDER, this.getWorkName()); } } return false; } parseResponse(t3) { let u3 = JSON.parse(t3.result)[BLOCK_LIST]?.[EVENT_LIST_V3] ?? []; this.sdkContext.dispatcher().emit(Topic.BlockListUpdate, { "blocklist": u3 }); this.sdkContext.kvStore().put(BLOCK_LIST, u3); } buildEventRequestBody(o3, p3, q3) { let r3 = {}; r3[KEY_MAGIC] = KEY_MAGIC_VALUE; r3[KEY_HEADER] = mapToRecord(this.sdkContext.headerManager().getHeader()); if (o3.length > 0) { r3[KEY_LAUNCH] = o3; } if (p3.length > 0) { r3[KEY_TERMINATE] = p3; } if (q3.length > 0) { r3[KEY_EVENT] = q3; } let s3 = currentTimeMillis(); r3[KEY_LOCAL_TIME] = s3 / 1000; r3[KEY_GEN_TIME] = s3; return JSON.stringify(r3); } getRetryIntervals() { return RETRY_INTERVALS; } } export async function checkEventSsidReady(q2, r2, s2) { if (!BuildProfile.isSDKSsidMaintain) { r2.appLogLogger().debug("Jump checkEventSsidReady, because don't need sdk maintain ssid.", LoggerTag.USER); return; } let t2 = q2; let u2 = t2.filter((n3) => { return isEmpty(n3[KEY_SSID]); }); if (isArrayEmpty(u2)) { r2.appLogLogger() .info("{} checkEventSsidReady events have ssid, no need to request", LoggerTag.SENDER, s2, u2); return; } let v2 = t2.reduce((h3, i3, j3, k3) => { let l3 = i3[KEY_USER_UNIQUE_ID]; let m3; if (h3.has(l3)) { m3 = h3.get(l3); m3.push(i3); } else { m3 = []; m3.push(i3); } h3.set(l3, m3); return h3; }, new Map()); for (let w2 of v2.keys()) { let x2 = v2.get(w2); let y2 = x2.filter((g3) => { return isEmpty(g3[KEY_SSID]); }); let z2 = x2.filter((f3) => { return isNotEmpty(f3[KEY_SSID]); }); r2.appLogLogger() .info("{} checkEventSsidReady uuid: {}, emptySsidEvents len: {}, hasSsidEvents len: {}", LoggerTag.SENDER, s2, w2, y2.length, z2.length); if (isArrayEmpty(z2)) { let c3 = r2.headerManager().getValue(KEY_USER_UNIQUE_ID, ""); let d3 = ""; if (strEquals(c3, w2)) { d3 = r2.headerManager().getValue(KEY_SSID, ""); r2.appLogLogger() .info("{} checkEventSsidReady uuid: {}, use header ssid, ssid: {}", LoggerTag.SENDER, s2, w2, d3); } else { d3 = await r2.workEngine() .queryWorker(RegisterWorker.workName)?.fetchSsidFromRemote(w2); r2.appLogLogger() .info("{} checkEventSsidReady uuid: {}, fetchSsidFromRemote success, ssid: {}", LoggerTag.SENDER, s2, w2, d3); } if (isNotEmpty(d3)) { for (let e3 of y2) { e3[KEY_SSID] = d3; } } else { r2.appLogLogger() .info("{} checkEventSsidReady uuid: {}, fetchSsidFromRemote failed", LoggerTag.SENDER, s2, w2); } } else { let a3 = z2[0][KEY_SSID]; r2.appLogLogger() .info("{} checkEventSsidReady uuid: {}, use local ssid, ssid: {}", LoggerTag.SENDER, s2, w2, a3); for (let b3 of y2) { b3[KEY_SSID] = z2[0][KEY_SSID]; } } } } 