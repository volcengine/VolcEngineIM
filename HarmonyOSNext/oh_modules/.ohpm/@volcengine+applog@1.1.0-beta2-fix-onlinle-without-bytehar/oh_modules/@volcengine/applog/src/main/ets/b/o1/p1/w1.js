import * as o4 from "./q1"; import LoggerTag from "../../h1/j1"; import bundleManager from "@ohos.bundle.bundleManager"; import { isEmpty, isNotEmpty } from "../../k1/l1"; import { checkDidValid, getDidInfo, isHeaderDidReady } from "../../k1/v2"; import { currentTimeMillis, getTimeZone, getTimeZoneName, getTimeZoneOffset } from "../../k1/k2"; import * as p4 from "../../k1/w2"; import { getNetworkType } from "../../u1/p2"; import { getDensityDensity, getDensityDPI } from "../../k1/x2"; import { queryAssetAppLogId } from "../../k1/y2"; import deviceInfo from "@ohos.deviceInfo"; import q4 from '@ohos.i18n'; import BuildProfile from "../../../../../../a"; import Topic from "../../k/l"; import RegisterWorker from "../t2/u2"; export const HARMONY_OS = BuildProfile.sdkPlatform; export class HeaderManager { constructor(r5) { this.headerLoadFinish = false; this.header = new Map(); this.stagingAreaHeader = new Map(); this.sdkContext = r5; this.waitSDKStart(); this.sdkContext.workEngine().addWorker(new RegisterWorker(r5)); } waitSDKStart() { this.sdkContext.dispatcher().once(Topic.SDKStart, () => { this.prepare().then(() => { this.sdkContext.dispatcher().emit(Topic.HeaderReady); }); }); } prepare() { return this.loadHeader().then(() => { this.sdkContext.appLogLogger().debug("LoadHeader finish {}", LoggerTag.HEADER, this.header); return true; }).catch((q5) => { this.sdkContext.appLogLogger().error("LoadHeader failed.", q5, LoggerTag.HEADER); return false; }); } updateHeader(m5, n5, o5) { if (this.headerLoadFinish) { let p5 = this.header.get(m5); this.putIntoHeader(m5, n5); this.sdkContext.appLogLogger() .debug("UpdateHeader key: {} success, oldValue: {}, newValue: {}.", LoggerTag.HEADER, m5, p5, n5); } else { this.stagingAreaHeader.set(m5, n5); this.sdkContext.appLogLogger() .warn("UpdateHeader key: {} to staging area, wait header load finish deal", LoggerTag.HEADER, m5); } if (o5) { this.saveToKvStore(m5, n5); } } saveToKvStore(k5, l5) { this.sdkContext.appLogLogger() .debug("Header saveToKvStore key: {}, value: {}", LoggerTag.HEADER, k5, l5); if (typeof l5 === "string") { this.sdkContext.kvStore().put(k5, l5); } else if (typeof l5 === "number") { this.sdkContext.kvStore().put(k5, l5); } else if (l5 == null) { this.sdkContext.kvStore().delete(k5); } else { this.sdkContext.appLogLogger() .warn("Header saveToKvStore failed, not support type {}", LoggerTag.HEADER, typeof l5); } } getValue(i5, j5) { if (this.headerLoadFinish && this.header.has(i5)) { this.sdkContext.appLogLogger() .debug("Header getValue key: {} from header", LoggerTag.HEADER, i5); return this.header.get(i5); } else if (this.stagingAreaHeader.has(i5)) { this.sdkContext.appLogLogger() .debug("Header getValue key: {} from staging area", LoggerTag.HEADER, i5); return this.stagingAreaHeader.get(i5); } else if (typeof j5 === "string") { this.sdkContext.appLogLogger() .debug("Header getValue key: {} from kv store", LoggerTag.HEADER, i5); return this.sdkContext.kvStore().get(i5, j5); } return j5; } getHeader() { if (this.headerLoadFinish) { return this.header; } else { this.sdkContext.appLogLogger().debug("GetHeader failed, not finish load header.", LoggerTag.HEADER); return new Map(); } } async loadHeader() { let w4 = currentTimeMillis(); this.sdkContext.appLogLogger().debug("LoadHeader start", LoggerTag.HEADER); this.putIntoHeader(o4.KEY_AID, this.sdkContext.sdkConfig().getAppId()); this.putIntoHeader(o4.KEY_CHANNEL, this.sdkContext.sdkConfig().getChannel()); this.putIntoHeader(o4.KEY_LANGUAGE, q4.System.getSystemLanguage()); this.putIntoHeader(o4.KEY_REGION, q4.System.getSystemRegion()); this.putIntoHeader(o4.KEY_TIMEZONE, getTimeZone()); this.putIntoHeader(o4.KEY_TZ_NAME, getTimeZoneName()); this.putIntoHeader(o4.KEY_TZ_OFFSET, getTimeZoneOffset()); this.putIntoHeader(o4.KEY_CDID, p4.queryOrGenerateUUID(o4.KEY_CDID, this.sdkContext.kvStore())); let x4 = await p4.queryOrGetOaid(o4.KEY_OAID, this.sdkContext); if (x4) { let h5 = { "id": x4 }; this.header.set(o4.KEY_OAID, h5); } let y4 = await p4.queryOrGetAaid(o4.KEY_AAID, this.sdkContext); this.putIntoHeader(o4.KEY_AAID, y4); this.putIntoHeader(o4.KEY_ODID, deviceInfo.ODID); this.putIntoHeader(o4.KEY_SIM_REGION, await p4.getSimRegion(this.sdkContext.appLogLogger())); this.putIntoHeader(o4.KEY_MCC_MNC, await p4.getMnnMnc(this.sdkContext.appLogLogger())); this.putIntoHeader(o4.KEY_CLIENT_UDID, p4.queryOrGenerateUUID(o4.KEY_CLIENT_UDID, this.sdkContext.kvStore())); let z4 = await queryAssetAppLogId(this.sdkContext.appLogLogger()); if (HARMONY_OS === "openHarmony") { this.putIntoHeader(o4.KEY_HARMONY_ID, z4); } else { if (isEmpty(z4)) { z4 = y4; this.sdkContext.appLogLogger().debug("AssetId use aaid", LoggerTag.HEADER); } this.putIntoHeader(o4.KEY_OPEN_UDID, z4); } this.putIntoHeader(o4.KEY_PLATFORM, HARMONY_OS); this.putIntoHeader(o4.KEY_SDK_LIB, HARMONY_OS); this.putIntoHeader(o4.KEY_SDK_VERSION, BuildProfile.sdkVersionName); let a5 = 10000000; let b5 = BuildProfile.sdkVersionName.split("."); this.putIntoHeader(o4.KEY_SDK_VERSION_CODE, a5 + parseInt(b5[0]) * 10000 + parseInt(b5[1]) * 100 + parseInt(b5[2])); this.putIntoHeader(o4.KEY_SDK_VERSION_NAME, BuildProfile.sdkVersionName); this.putIntoHeader(o4.KEY_DEVICE_MODEL, deviceInfo.productModel); this.putIntoHeader(o4.KEY_DEVICE_BRAND, deviceInfo.brand); this.putIntoHeader(o4.KEY_DEVICE_MANUFACTURER, deviceInfo.manufacture); this.putIntoHeader(o4.KEY_DEVICE_TYPE, deviceInfo.deviceType); this.putIntoHeader(o4.KEY_OS, HARMONY_OS); this.putIntoHeader(o4.KEY_OS_API, deviceInfo.sdkApiVersion); this.putIntoHeader(o4.KEY_OS_VERSION, deviceInfo.distributionOSVersion); this.putIntoHeader(o4.KEY_CPU_ABI, deviceInfo.abiList); let c5 = bundleManager.BundleFlag.GET_BUNDLE_INFO_DEFAULT; let d5 = bundleManager.getBundleInfoForSelfSync(c5); this.putIntoHeader(o4.KEY_PACKAGE, d5.name); this.putIntoHeader(o4.KEY_APP_VERSION, d5.versionName); this.putIntoHeader(o4.KEY_VERSION_CODE, d5.versionCode); this.putIntoHeader(o4.KEY_INSTALL_TIME, d5.installTime); this.putIntoHeader(o4.KEY_UPDATE_TIME, d5.updateTime); this.putIntoHeader(o4.KEY_FINGERPRINT, d5.signatureInfo?.fingerprint); this.putIntoHeader(o4.KEY_DISPLAY_NAME, this.sdkContext.context() .resourceManager .getStringSync(this.sdkContext.context().applicationInfo.labelId)); this.putIntoHeader(o4.KEY_ACCESS, await getNetworkType(this.sdkContext.appLogLogger())); this.putIntoHeader(o4.KEY_DENSITY_DPI, getDensityDPI()); this.putIntoHeader(o4.KEY_RESOLUTION, getDensityDensity()); this.putIntoHeader(o4.KEY_AB_SDK_VERSION, this.sdkContext.kvStore() .get(o4.KEY_AB_SDK_VERSION, "")); this.putIntoHeader(o4.KEY_USER_UNIQUE_ID, this.sdkContext.kvStore() .get(o4.KEY_USER_UNIQUE_ID, "")); this.putIntoHeader(o4.KEY_USER_UNIQUE_ID_TYPE, this.sdkContext.kvStore() .get(o4.KEY_USER_UNIQUE_ID_TYPE, "")); let e5 = this.sdkContext.kvStore() .get(o4.KEY_BD_DID, ""); this.putIntoHeader(o4.KEY_BD_DID, e5); this.putIntoHeader(o4.KEY_DEVICE_ID, this.sdkContext.kvStore() .get(o4.KEY_DEVICE_ID, "")); this.putIntoHeader(o4.KEY_INSTALL_ID, this.sdkContext.kvStore() .get(o4.KEY_INSTALL_ID, "")); let f5 = false; if (BuildProfile.isSDKSsidMaintain) { let g5 = this.sdkContext.kvStore().get(o4.KEY_SSID, ""); this.putIntoHeader(o4.KEY_SSID, g5); f5 = checkDidValid(e5, g5); } else { f5 = checkDidValid(e5); } if (f5) { this.putIntoHeader(o4.KEY_REGISTER_TIME, this.sdkContext.kvStore() .get(o4.KEY_REGISTER_TIME, 0)); } else { this.putIntoHeader(o4.KEY_REGISTER_TIME, 0); this.sdkContext.appLogLogger() .info("LoadHeader checkDidValid false, reset last register time", LoggerTag.HEADER, currentTimeMillis() - w4); } this.checkStagingAreaHeader(); this.headerLoadFinish = true; this.sdkContext.appLogLogger() .info("LoadHeader end, cost: {}", LoggerTag.HEADER, currentTimeMillis() - w4); this.checkDidReady(); } checkStagingAreaHeader() { this.stagingAreaHeader.forEach((u4, v4) => { this.putIntoHeader(v4, u4); this.sdkContext.appLogLogger() .debug("Update staging area header key: {}  value: {} to header", LoggerTag.HEADER, v4, u4); }); } checkDidReady() { if (isHeaderDidReady(this.sdkContext.headerManager())) { let t4 = getDidInfo(this.sdkContext); t4[o4.KEY_DEVICE_INFO_FROM] = o4.KEY_DID_FORM_LOCAL; this.sdkContext.dispatcher().emit(Topic.DidReady, t4); this.sdkContext.appLogLogger().debug("Local did ready -> {}...", LoggerTag.HEADER, t4); } } putIntoHeader(r4, s4) { if (s4 == null) { this.header.delete(r4); } else if (typeof s4 === "string") { if (isNotEmpty(s4)) { this.header.set(r4, s4); } else { this.header.delete(r4); } } else { this.header.set(r4, s4); } } } 